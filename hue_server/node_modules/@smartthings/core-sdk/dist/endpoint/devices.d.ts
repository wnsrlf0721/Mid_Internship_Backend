import { Endpoint } from '../endpoint';
import { EndpointClientConfig } from '../endpoint-client';
import { ConfigEntry } from './installedapps';
import { Links, Status } from '../types';
import { PresentationDevicePresentation } from './presentation';
export interface CapabilityReference {
    id: string;
    version?: number;
    status?: CapabilityStatus;
}
export interface Component {
    id?: string;
    label?: string;
    capabilities: CapabilityReference[];
}
export interface AppDeviceDetails {
    installedAppId?: string;
    externalId?: string;
    profileId?: string;
}
export declare enum DeviceNetworkSecurityLevel {
    UNKNOWN = "UNKNOWN",
    ZWAVE_LEGACY_NON_SECURE = "ZWAVE_LEGACY_NON_SECURE",
    ZWAVE_S0_LEGACY = "ZWAVE_S0_LEGACY",
    ZWAVE_S0_FALLBACK = "ZWAVE_S0_FALLBACK",
    ZWAVE_S2_UNAUTHENTICATED = "ZWAVE_S2_UNAUTHENTICATED",
    ZWAVE_S2_AUTHENTICATED = "ZWAVE_S2_AUTHENTICATED",
    ZWAVE_S2_ACCESS_CONTROL = "ZWAVE_S2_ACCESS_CONTROL",
    ZWAVE_S2_FAILED = "ZWAVE_S2_FAILED",
    ZWAVE_S0_FAILED = "ZWAVE_S0_FAILED",
    ZWAVE_S2_DOWNGRADE = "ZWAVE_S2_DOWNGRADE",
    ZWAVE_S0_DOWNGRADE = "ZWAVE_S0_DOWNGRADE"
}
export interface DthDeviceDetails {
    deviceTypeId: string;
    deviceTypeName: string;
    deviceNetworkType?: string;
    completedSetup: boolean;
    networkSecurityLevel?: DeviceNetworkSecurityLevel;
    hubId?: string;
    installedGroovyAppId?: string;
}
export interface IrDeviceDetails {
    parentDeviceId?: string;
    profileId?: string;
    ocfDeviceType?: string;
    irCode?: string;
    functionCodes?: {
        default: string;
    };
    childDevices?: IrDeviceDetails[];
    metadata?: object;
}
export interface ViperDeviceDetails {
    uniqueIdentifier?: string;
    manufacturerName?: string;
    modelName?: string;
    swVersion?: string;
    hwVersion?: string;
}
export declare enum DeviceIntegrationType {
    BLE = "BLE",
    BLE_D2D = "BLE_D2D",
    DTH = "DTH",
    ENDPOINT_APP = "ENDPOINT_APP",
    HUB = "HUB",
    IR = "IR",
    IR_OCF = "IR_OCF",
    MQTT = "MQTT",
    OCF = "OCF",
    PENGYOU = "PENGYOU",
    VIDEO = "VIDEO",
    VIPER = "VIPER",
    WATCH = "WATCH"
}
export interface ProfileIdentifier {
    id: string;
}
export interface HealthState {
    state: DeviceHealthState;
    lastUpdatedDate?: string;
}
export interface Device {
    deviceId?: string;
    name?: string;
    label?: string;
    manufacturerName?: string;
    presentationId?: string;
    deviceManufacturerCode?: string;
    locationId?: string;
    roomId?: string;
    deviceTypeId?: string;
    components?: Component[];
    childDevices?: Device[];
    profile?: ProfileIdentifier;
    app?: AppDeviceDetails;
    dth?: DthDeviceDetails;
    ir?: IrDeviceDetails;
    irOcf?: IrDeviceDetails;
    viper?: ViperDeviceDetails;
    type?: DeviceIntegrationType;
    restrictionTier?: number;
    healthState?: HealthState;
}
export interface DeviceUpdate {
    label?: string;
}
export interface DeviceProfileUpdate {
    profileId: string;
}
export interface DeviceCreate {
    label?: string;
    locationId?: string;
    app?: AppDeviceDetails;
    profileId?: undefined;
}
export interface AlternateDeviceCreate {
    label?: string;
    locationId?: string;
    installedAppId?: string;
    externalId?: string;
    profileId?: string;
    app?: undefined;
}
export interface DeviceList {
    items: Device[];
    _links: Links;
}
interface AttributeState {
    value?: unknown;
    unit?: string;
    data?: {
        [name: string]: object;
    };
    timestamp?: string;
}
export interface CapabilityStatus {
    [attributeName: string]: AttributeState;
}
export interface ComponentStatus {
    [attributeName: string]: CapabilityStatus;
}
export interface DeviceStatus {
    components?: {
        [componentId: string]: ComponentStatus;
    };
}
export interface DeviceEvent {
    component: string;
    capability: string;
    attribute: string;
    value: unknown;
    unit?: string;
    data?: {
        [name: string]: object;
    };
}
export interface DeviceEventList {
    deviceEvents: DeviceEvent[];
}
export declare enum DeviceHealthState {
    ONLINE = "ONLINE",
    OFFLINE = "OFFLINE",
    UNKNOWN = "UNKNOWN"
}
export interface DeviceHealth {
    deviceId: string;
    state: DeviceHealthState;
    lastUpdatedDate?: string;
}
export interface Command {
    component: string;
    capability: string;
    command: string;
    arguments?: (object | string | number)[];
}
export interface CommandRequest {
    capability: string;
    command: string;
    arguments?: (object | string | number)[];
}
export interface CommandList {
    commands: Command[];
}
export declare type PreferenceType = 'integer' | 'number' | 'boolean' | 'string' | 'enumeration';
export interface DevicePreferenceEntry {
    preferenceType: PreferenceType;
    value: string | number | boolean;
}
export interface DevicePreferenceResponse {
    /**
     * Map of preference name to its stored value
     */
    values: Partial<Record<string, DevicePreferenceEntry>>;
}
export interface DeviceListOptions {
    /**
     * Capability ID (for example, 'switchLevel') or array of capability IDs
     */
    capability?: string | string[];
    /**
     * Whether to AND or OR the capability IDs when more than one is specified
     */
    capabilitiesMode?: 'and' | 'or';
    /**
     * Location UUID or array of location UUIDs
     */
    locationId?: string | string[];
    /**
     * Device UUID or array of device UUIDs
     */
    deviceId?: string | string[];
    /**
     * UUID of an installed app instance
     */
    installedAppId?: string;
    /**
     * Include the device health, i.e. online/offline status in the response
     */
    includeHealth?: boolean;
    /**
     * Include the device status data, i.e. the values of all attributes, in the response
     */
    includeStatus?: boolean;
    /**
     * Limit the number of results to this value. By default all devices are returned
     */
    max?: number;
    /**
     * Page number for when a max number of results has been specified, starting with 1
     */
    page?: number;
    /**
     * Device Type
     */
    type?: DeviceIntegrationType | DeviceIntegrationType[];
}
export interface DeviceGetOptions {
    /**
     * Include the device health, i.e. online/offline status in the response
     */
    includeHealth?: boolean;
    /**
     * Include the device status data, i.e. the values of all attributes, in the response
     */
    includeStatus?: boolean;
}
export interface HueSaturation {
    hue: number;
    saturation: number;
}
export declare class DevicesEndpoint extends Endpoint {
    constructor(config: EndpointClientConfig);
    /**
     * Returns a list of devices matching the query options or all devices accessible by the principal (i.e. user)
     * if no options are specified. If the includeHealth option is set to true then the response will also contain
     * the health status of each device (i.e. if it is online or offline). If the includeStatus option is set to true
     * then the response will also include the status of all attributes (i.e. value and timestamp)
     *
     * @param options query options, capability, capabilitiesMode ('and' or 'or'), locationId, deviceId. which can
     * be single values or arrays, and includeHealth & includeStatus booleans
     */
    list(options?: DeviceListOptions): Promise<Device[]>;
    /**
     * Returns all devices in the location specified in the client configuration. Throws an error if no location is
     * specified in the client config. For use only in SmartApps.
     * @deprecated use list() instead
     */
    listInLocation(): Promise<Device[]>;
    /**
     * Returns all devices accessible by the principal (i.e. user)
     * @deprecated use list() instead
     */
    listAll(): Promise<Device[]>;
    /**
     * Returns devices with the specified capability.
     * @deprecated use list({capability: 'switch'} instead
     */
    findByCapability(capability: string): Promise<Device[]>;
    /**
     * Returns a description of the specified device
     * @param id UUID of the device
     * @param options optional includeHealth and includeStatus parameters.
     * If the includeHealth option is set to true then the response will also contain
     * the health status of each device (i.e. if it is online or offline). If the includeStatus option is set to true
     * then the response will also include the status of all attributes (i.e. value and timestamp)
     */
    get(id: string, options?: DeviceGetOptions): Promise<Device>;
    /**
     * Deletes the specified device
     * @param id UUID of the device
     */
    delete(id: string): Promise<Device>;
    /**
     * Install a device.
     * @param definition the device definition. If the client configuration specifies a locationId and installedAppId
     * then these values don't need to be included in the definition.
     */
    create(definition: DeviceCreate | AlternateDeviceCreate): Promise<Device>;
    /**
     * Update a device. Currently only the device label can be changed
     * @param id UUID of the device
     * @param data new device definition with the label specified
     */
    update(id: string, data: DeviceUpdate): Promise<Device>;
    /**
     * Update the deviceProfileId of a device. Note that currently this method can
     * only be called with an installedApp token with the i:deviceprofiles scope
     * on a device created by that app.
     * @param id UUID of the device
     * @param data the new device profile
     */
    updateProfile(id: string, data: DeviceProfileUpdate): Promise<Device>;
    /**
     * Returns the current values of all device attributes
     * @param id UUID of the device
     */
    getStatus(id: string): Promise<DeviceStatus>;
    /**
     * Returns the current values of all device attributes
     * @deprecated use getStatus instead
     */
    getState(id: string): Promise<DeviceStatus>;
    /**
     * Gets the attribute values of the specified component of the device
     * @param id UUID of the device
     * @param componentId alphanumeric component ID, e.g. 'main'
     */
    getComponentStatus(id: string, componentId: string): Promise<ComponentStatus>;
    /**
     * Gets the attribute values of the specified component of the device
     * @deprecated use getComponentStatus instead
     */
    getComponentState(id: string, componentId: string): Promise<ComponentStatus>;
    /**
     * Gets the attribute values of the specified component capability
     * @param id UUID of the device
     * @param componentId alphanumeric component ID, e.g. 'main'
     * @param capabilityId alphanumeric capability ID, e.g. 'switchLevel'
     */
    getCapabilityStatus(id: string, componentId: string, capabilityId: string): Promise<CapabilityStatus>;
    /**
     * Gets the attribute values of the specified component capability
     * @deprecated use getCapabilityStatus instead
     */
    getCapabilityState(id: string, componentId: string, capabilityId: string): Promise<CapabilityStatus>;
    /**
     * Returns the health status of the device
     * @param id UUID of the device
     */
    getHealth(id: string): Promise<DeviceHealth>;
    /**
     * Sends the specified list of commands to the device
     * @param id UUID of the device
     * @param commands list of commands
     */
    executeCommands(id: string, commands: Command[]): Promise<Status>;
    /**
     * Sends the specified command to the device
     * @param id UUID of the device
     * @param command a single device command
     */
    executeCommand(id: string, command: Command): Promise<Status>;
    /**
     * Sends the specified commands to the device
     * @deprecated use executeCommands instead
     */
    postCommands(id: string, commands: CommandList): Promise<Status>;
    /**
     * Sends the specified command or commands to the device and component defined in the specified config entry. The
     * end result is the same as calling the executeCommand method, but this method accepts a SmartApp config entry
     * for convenience
     * @param item installedApp config entry specifying the device UUID and component
     * @param capabilityIdOrCmdList either a capability ID or list of commands. If a list of commands is specified
     * then the command and args parameters are not required.
     * @param command the command name. Required when a capability ID has been specified in the previous parameter
     * @param args list of arguments. Required when a capability ID has been specified and the command has arguments
     */
    sendCommand(item: ConfigEntry, capabilityIdOrCmdList: string | CommandRequest[], command?: string, args?: (object | string | number)[]): Promise<Status>;
    /**
     * Sends the specified command or commands to the devices and components defined in the specified config entry list. The
     * end result is the same as calling the executeCommand method, but this method accepts a SmartApp config entry
     * for convenience
     * @param items a list of the installedApp config entries specifying device UUIDs and component IDs
     * @param capabilityIdOrCmdList either a capability ID or list of commands. If a list of commands is specified
     * then the command and args parameters are not required.
     * @param command the command name. Required when a capability ID has been specified in the previous parameter
     * @param args list of arguments. Required when a capability ID has been specified and the command has arguments
     */
    sendCommands(items: ConfigEntry[], capabilityIdOrCmdList: string | CommandRequest[], command: string, args?: (object | string | number)[]): Promise<Status[]>;
    /**
     * Creates events for the specified device
     * @param id UUID of the device
     * @param deviceEvents list of events
     */
    createEvents(id: string, deviceEvents: DeviceEvent[]): Promise<Status>;
    /**
     * @deprecated use createEvents instead
     * @param id
     * @param deviceEvents
     */
    sendEvents(id: string, deviceEvents: DeviceEventList): Promise<void>;
    /**
     * Get a device presentation. If mnmn is omitted the default SmartThingsCommunity mnmn is used.
     * @param deviceId UUID of the device
     */
    getPresentation(deviceId: string): Promise<PresentationDevicePresentation>;
    /**
     * Get the preference values of the device
     * @param deviceId UUID of the device
     */
    getPreferences(deviceId: string): Promise<DevicePreferenceResponse>;
    /**
     * Convenience function that returns hue and saturation of the named color
     * @deprecated
     */
    namedColor(color: string, sat?: number): HueSaturation;
}
export {};
//# sourceMappingURL=devices.d.ts.map